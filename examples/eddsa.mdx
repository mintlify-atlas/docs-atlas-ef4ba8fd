---
title: 'EdDSA Signature Verification'
description: 'Verify EdDSA signatures using Poseidon2 hash'
---

This example demonstrates EdDSA (Edwards-curve Digital Signature Algorithm) signature verification in zero-knowledge using Poseidon2 hash function and the BabyJubJub elliptic curve.

## Circuit Overview

The circuit verifies EdDSA signatures without revealing the message or signature components. It uses the BabyJubJub curve (a twisted Edwards curve) and Poseidon2 for hashing, making it highly efficient for zero-knowledge proofs.

## Circuit Code

From `noir-examples/eddsa_poseidon2/src/lib.nr`:

```noir
// EdDSA Poseidon2 Verifier for Noir
// Complete implementation of EdDSA signature verification using Poseidon2 hash

use babyjubjub::BabyJubJubPoint;
use poseidon2::bn254::perm;

// Domain separator for EdDSA signatures: b"EdDSA Signature"
global DOMAIN_SEPARATOR: Field = 360302137480307891234917541314130533;

/// EdDSA Poseidon2 Verifier
///
/// Verifies an EdDSA signature using Poseidon2 hash function
///
/// # Inputs
/// - pub_key_x: The x coordinate of the public key
/// - pub_key_y: The y coordinate of the public key
/// - signature_s: The scalar component of the signature
/// - signature_r: The point component of the signature
/// - message: The message that was signed
///
/// # Verification Equation (cofactored)
/// 8*(S*G - R - h*A) == Identity
/// where h = Poseidon2(domain_separator, Rx, Ry, Ax, Ay, M, 0, 0)
pub fn verify_eddsa_poseidon2(
    pub_key_x: Field,
    pub_key_y: Field,
    signature_s: Field,
    signature_r: [Field; 2],
    message: Field,
) -> bool {
    // Step 1 - Validate S is in BabyJubJub scalar field
    BabyJubJubPoint::validate_babyjubjub_field(signature_s);

    // Step 2 - Validate public key A
    let a_point = BabyJubJubPoint::new(pub_key_x, pub_key_y);
    assert(a_point.is_on_curve(), "Public key must be on curve");
    assert(a_point.check_sub_group(), "Public key must be in subgroup");
    assert(a_point.is_not_identity(), "Public key cannot be identity");

    // Step 3 - Validate R is on the curve
    let r_point = BabyJubJubPoint::new(signature_r[0], signature_r[1]);
    assert(r_point.is_on_curve(), "R must be on curve");

    // Step 4 - Compute h = Poseidon2(domain_separator, Rx, Ry, Ax, Ay, M, 0, 0)
    let hash_state = perm::x5_8([
        DOMAIN_SEPARATOR,
        signature_r[0],
        signature_r[1],
        pub_key_x,
        pub_key_y,
        message,
        0,
        0,
    ]);

    let hash = hash_state[1];

    // Step 5 - Compute right side: R + h*A
    let right2 = a_point.scalar_mul_base_field(hash);
    let right = r_point.add(right2);

    // Step 6 - Compute left side: S*G
    let left = BabyJubJubPoint::generator_scalar_mul(signature_s);

    // Step 7 - Compute v = S*G - R - h*A = S*G - (R + h*A)
    let v = left.subtract(right);

    // Step 8 - Check if v is the identity (cofactor check: 8*v == identity)
    v.double().double().double().is_identity()
}
```

### What This Circuit Does

1. **Validates Inputs**: Ensures signature scalar `s` is in the valid field range
2. **Public Key Validation**: Verifies the public key `A` is on the curve and in the correct subgroup
3. **R Point Validation**: Checks that signature point `R` is on the curve
4. **Hash Computation**: Computes challenge hash `h = Poseidon2(domain_sep, R, A, message)`
5. **Signature Equation**: Verifies `S*G = R + h*A` using elliptic curve operations
6. **Cofactor Check**: Applies cofactor multiplication to handle curve subgroups
7. **Identity Check**: Confirms the verification equation holds

## EdDSA Signature Components

### Public Key
- **pub_key_x**: X-coordinate of public key point `A`
- **pub_key_y**: Y-coordinate of public key point `A`
- Public key must be in the prime-order subgroup of BabyJubJub

### Signature
- **signature_r**: Point `R = [r_x, r_y]` on BabyJubJub curve
- **signature_s**: Scalar `s` in the BabyJubJub field
- Generated by signer using private key

### Message
- **message**: Field element representing the message
- Can be a hash of larger data
- Used in challenge hash computation

## Input Configuration

The `Prover.toml` file needs signature data:

```toml
x = ""
y = ""
```

Note: This example requires generating a valid EdDSA signature. Here's how to prepare inputs:

### Generating Test Inputs

```javascript
// Using circomlibjs or similar library
const eddsa = require('circomlibjs').eddsa;
const poseidon = require('circomlibjs').poseidon;

// Generate private key
const privateKey = Buffer.from('1'.repeat(64), 'hex');

// Derive public key
const publicKey = eddsa.prv2pub(privateKey);

// Sign a message
const message = BigInt(12345);
const signature = eddsa.signPoseidon(privateKey, message);

console.log('pub_key_x =', publicKey[0].toString());
console.log('pub_key_y =', publicKey[1].toString());
console.log('signature_r = [', signature.R8[0].toString(), ',', signature.R8[1].toString(), ']');
console.log('signature_s =', signature.S.toString());
console.log('message =', message.toString());
```

Update `Prover.toml` with these values:
```toml
pub_key_x = "17777552123799933955779906779655732241715742912184938656739573121738514868268"
pub_key_y = "2626589144620713026669568689430873010625803728049924121243784502389097019475"
signature_r = ["1234...", "5678..."]
signature_s = "9876..."
message = "12345"
```

## Complete Workflow

### 1. Generate Signature (Off-Chain)

First, generate a valid EdDSA signature using a library:

```bash
node generate-signature.js > signature.json
```

This creates a JSON file with:
```json
{
  "pub_key_x": "17777...",
  "pub_key_y": "26265...",
  "signature_r": ["...", "..."],
  "signature_s": "...",
  "message": "12345"
}
```

### 2. Update Prover.toml

Copy values from `signature.json` to `Prover.toml`:

```bash
node update-prover-toml.js signature.json
```

### 3. Compile Circuit

Compile the EdDSA verification circuit:

```bash
nargo compile
```

Expected output:
```
Compiling circuit: eddsa_poseidon2
Including dependencies:
  - babyjubjub (elliptic curve operations)
  - poseidon2 (hash function)
Circuit size: ~5,000 constraints
Compilation complete
```

### 4. Prepare Proving System

Generate keys:

```bash
provekit prepare eddsa_poseidon2
```

Expected output:
```
Preparing circuit: eddsa_poseidon2
Curve: BabyJubJub on BN254
Generating proving key...
Generating verification key...
Preparation complete
```

### 5. Generate Proof

Create a ZK proof of signature validity:

```bash
provekit prove eddsa_poseidon2
```

Expected output:
```
Generating proof for: eddsa_poseidon2
Validating public key... ✓
Validating signature point R... ✓
Computing challenge hash h... ✓
Verifying signature equation S*G = R + h*A... ✓
Performing cofactor check... ✓
Signature is valid!
Proof generated successfully
```

### 6. Verify Proof

Verify the signature proof:

```bash
provekit verify eddsa_poseidon2 proof.json
```

Expected output:
```
Verifying proof for: eddsa_poseidon2
Signature verification successful
Proof is valid
```

## EdDSA Algorithm Details

### Verification Equation

EdDSA verifies signatures using:
```
S * G = R + h * A
```

Where:
- `G` = BabyJubJub generator point
- `A` = Public key point
- `R` = Signature point (part of signature)
- `S` = Signature scalar (part of signature)
- `h` = Challenge hash `Poseidon2(domain, R, A, message)`

### Why Cofactor Check?

BabyJubJub has cofactor 8, so we check:
```
8 * (S*G - R - h*A) = Identity
```

Implemented as:
```noir
v.double().double().double().is_identity()
```

This ensures the signature is in the prime-order subgroup.

### Domain Separation

The domain separator prevents cross-protocol attacks:
```noir
global DOMAIN_SEPARATOR: Field = 360302137480307891234917541314130533;
```

This is the field representation of "EdDSA Signature".

## BabyJubJub Curve

### Curve Equation

BabyJubJub is a twisted Edwards curve:
```
a*x^2 + y^2 = 1 + d*x^2*y^2
```

Parameters:
- `a = 168700`
- `d = 168696`
- Prime order subgroup
- Efficient for ZK circuits

### Point Operations

The circuit uses:
- **Addition**: `add(P, Q)` - Point addition
- **Scalar Multiplication**: `scalar_mul(k, P)` - Multiply point by scalar
- **Generator Multiplication**: `generator_scalar_mul(k)` - Efficient G multiplication
- **Doubling**: `double()` - Efficient point doubling

## Use Cases

### Anonymous Authentication

Prove you possess a valid signature without revealing identity:
```noir
fn anonymous_auth(
    pub_key_x: Field,
    pub_key_y: Field,
    signature: Signature,
    message: Field
) {
    assert(verify_eddsa_poseidon2(
        pub_key_x, pub_key_y,
        signature.s, signature.r,
        message
    ));
    // Public key can be kept private
}
```

### Credential Verification

Verify signed credentials in ZK:
```noir
fn verify_credential(
    issuer_pubkey: PubKey,
    credential_data: Field,
    signature: Signature
) -> bool {
    let credential_hash = poseidon2::hash_1([credential_data]);
    verify_eddsa_poseidon2(
        issuer_pubkey.x,
        issuer_pubkey.y,
        signature.s,
        signature.r,
        credential_hash
    )
}
```

### Multi-Signature Schemes

Verify multiple signatures:
```noir
fn verify_multisig(
    pubkeys: [PubKey; N],
    signatures: [Signature; N],
    message: Field,
    threshold: u32
) {
    let mut valid_count = 0;
    for i in 0..N {
        if verify_eddsa_poseidon2(
            pubkeys[i].x, pubkeys[i].y,
            signatures[i].s, signatures[i].r,
            message
        ) {
            valid_count += 1;
        }
    }
    assert(valid_count >= threshold);
}
```

### Signed Message Chains

Verify chains of signed messages:
```noir
fn verify_message_chain(
    pubkey: PubKey,
    messages: [Field; N],
    signatures: [Signature; N]
) {
    for i in 0..N {
        assert(verify_eddsa_poseidon2(
            pubkey.x, pubkey.y,
            signatures[i].s, signatures[i].r,
            messages[i]
        ));
    }
}
```

## Performance Characteristics

### Constraint Count

- **Elliptic curve operations**: ~4,000 constraints
- **Poseidon2 hash**: ~100 constraints
- **Field validations**: ~100 constraints
- **Total**: ~5,000 constraints

### Proving Time

Approximate times:
- **Compilation**: ~5 seconds
- **Proving**: ~10 seconds
- **Verification**: ~100ms

### Comparison with ECDSA

| Algorithm | Constraints | Hash Function | Curve |
|-----------|-------------|---------------|-------|
| EdDSA (this) | ~5,000 | Poseidon2 | BabyJubJub |
| ECDSA | ~150,000 | SHA-256 | secp256k1 |

EdDSA with Poseidon2 is 30x more efficient!

## Advanced Patterns

### Batch Signature Verification

Verify multiple signatures efficiently:
```noir
fn batch_verify(
    pubkeys: [PubKey; N],
    messages: [Field; N],
    signatures: [Signature; N]
) -> [bool; N] {
    let mut results = [false; N];
    for i in 0..N {
        results[i] = verify_eddsa_poseidon2(
            pubkeys[i].x, pubkeys[i].y,
            signatures[i].s, signatures[i].r,
            messages[i]
        );
    }
    results
}
```

### Threshold Signatures

Implement t-of-n threshold verification:
```noir
fn threshold_verify(
    pubkeys: [PubKey; N],
    message: Field,
    signatures: [Option<Signature>; N],
    threshold: u32
) -> bool {
    let mut valid = 0;
    for i in 0..N {
        if signatures[i].is_some() {
            if verify_eddsa_poseidon2(
                pubkeys[i].x, pubkeys[i].y,
                signatures[i].unwrap().s,
                signatures[i].unwrap().r,
                message
            ) {
                valid += 1;
            }
        }
    }
    valid >= threshold
}
```

### Ring Signatures

Prove one of N signers signed (anonymity set):
```noir
fn ring_verify(
    pubkeys: [PubKey; N],
    message: Field,
    signature: Signature,
    signer_index: u32
) {
    // Verify signature with specific public key
    assert(verify_eddsa_poseidon2(
        pubkeys[signer_index].x,
        pubkeys[signer_index].y,
        signature.s, signature.r,
        message
    ));
    // signer_index kept private - anonymity in set
}
```

## Testing

Run the included tests:

```bash
nargo test
```

Tests verify:
- Valid signatures pass verification
- Invalid signatures fail
- Public key validation
- Cofactor checks

## Common Issues

### Invalid Public Key

```
Error: Public key must be on curve
```

Solution: Ensure public key coordinates satisfy the curve equation.

### Invalid Signature Point

```
Error: R must be on curve
```

Solution: Verify signature was generated correctly.

### Verification Failure

```
Assertion failed: v.is_identity()
```

Solution: Signature doesn't match public key or message was modified.

## Next Steps

- Generate your own EdDSA signatures
- Implement multi-signature verification
- Build an anonymous authentication system
- Explore ring signatures
- Compare with [SHA-256 example](/examples/sha256) for efficiency

## Related Examples

- [Basic Circuit](/examples/basic) - Simple Poseidon2 usage
- [Poseidon Rounds](/examples/poseidon) - Poseidon2 iterations
- [SHA-256](/examples/sha256) - Alternative hash (less efficient)
